/*
 * Offline ICP Localization.cpp
 *
 *  Created on: February 20, 2024
 *      Author: Meera Vijayakumar
 */

/**
 *
 * Offline Localization:
 * 1. Decode map generated by map server and publish as point cloud.
 *    This step involves converting the map generated by a map server into a point cloud.
 *
 * 2. Generate model cloud from image.
 *    Create a model cloud from images, capturing a detailed and accurate representation of the surroundings. This model cloud serves as a reference for localization.
 *
 * 3. Subscribe to laser callback at the current robot position.
 *    Subscribe to a laser callback that provides real-time data at the robot's current position. This laser scan data will be utilized for the subsequent localization steps.
 *
 * 4. Perform ICP for scan-to-map matching.
 *    Utilize the Iterative Closest Point (ICP) algorithm to match the laser scan data to the previously generated map point cloud. The ICP process refines the robot's pose relative to the map.
 *
 * 5. Get the score and provide pose relative to the map.
 *    Obtain a score from the ICP process, indicating the quality of the match between the laser scan and the map. Based on this successful ICP alignment, calculate and provide the robot's pose relative to the map.
 *
 * Purpose:
 * The Offline ICP Localization system aims to enable accurate robot navigation by leveraging map data, model clouds, and laser scans. By employing the ICP algorithm, it refines the robot's position in the environment, contributing to enhanced localization precision.
 */

#include <steer_bot_navigation/offline_localization_icp/offline_localization_icp.h>
#include <pcl/registration/correspondence_estimation.h>

offlineLocalization::offlineLocalization() //: icpExposed()
{
    ros::NodeHandle nh;
    ros::NodeHandle private_nh("~");

    bool default_publish_tf = false;
    ros::param::param<bool>("~to_publish_tf", to_publish_tf, default_publish_tf);

    default_fitness_threshold = 0.0002;
    ros::param::param<double>("~fitness_threshold", fitness_threshold, default_fitness_threshold);

    default_correspondence_distance = 1.0;
    ros::param::param<double>("~correspondence_distance", max_distance, default_correspondence_distance);

    int default_max_iterations = 1000;
    ros::param::param<int>("~max_iterations", max_iterations, default_max_iterations);

    int default_interpretation_count = 1;
    ros::param::param<int>("~further_interpretation_count", further_interpretation_count, default_interpretation_count);

    default_interpretation_threshold = 0.0002;
    ros::param::param<double>("~further_interpretation_threshold", further_interpretation_threshold, default_interpretation_threshold);

    int default_max_retry_count = 10;
    ros::param::param<int>("~max_retry_count", max_retry_count, default_max_retry_count);

    ros::param::param<std::string>("~map_folder", map_folder, "/tmp/feature_images/");

    ros::param::param<int>("~max_retry_count", max_retry_count, default_max_retry_count);
    ros::param::param<std::string>("~odom_topic", odom_topic, "odom");

    ros::param::param<std::string>("~localization_method", localizationMethodStr, "icp");

    ros::param::param<double>("~icp_localization/initial_pose/x", initialPose.pose.pose.position.x, 0.0);
    ros::param::param<double>("~icp_localization/initial_pose/y", initialPose.pose.pose.position.y, 0.0);
    ros::param::param<double>("~icp_localization/initial_pose/z", initialPose.pose.pose.position.z, 0.0);
    ros::param::param<double>("~icp_localization/initial_pose/roll", roll, 0.0);
    ros::param::param<double>("~icp_localization/initial_pose/pitch", pitch, 0.0);
    ros::param::param<double>("~icp_localization/initial_pose/yaw", yaw, 0.0);

    tf::Quaternion quat;
    quat.setRPY(roll, pitch, yaw);
    tf::quaternionTFToMsg(quat, initialPose.pose.pose.orientation);

    ros::param::param<std::string>("~global_frame_id", global_frame_id, "map");

    target_sub = nh.subscribe("target_laser_scan", 1, &offlineLocalization::sourceLaserCallback, this);
    initial_pose_sub = nh.subscribe("initialpose", 2,
                                    &offlineLocalization::initialPoseReceived, this);
    map_sub = nh.subscribe("map", 1,
                           &offlineLocalization::processOccupancyGrid, this);
    transformed_pattern_rviz_pub = nh.advertise<sensor_msgs::PointCloud2>("transformed_pattern", 1, true);
    laser_output_pub = nh.advertise<pcl::PointCloud<pcl::PointXYZ>>("/cloud_pcl", 100);
    score_pub = nh.advertise<std_msgs::Float32>("/localization_score", 100);



    // Initializing these values
    input_cloud_set = false;
    pose_sent = false;
    retry_done = true;
    map_received = false;
}

// pcl::CorrespondencesPtr offlineLocalization::getCorrespondences() 
// {
//     return correspondencesicp_ = this->icpExposed::getCorrespondencesPtr();
// }

pcl::KdTree<pcl::PointXYZ>::Ptr offlineLocalization::createKdTree(pcl::PointCloud<pcl::PointXYZ>::Ptr cloudb)
{
    pcl::KdTree<pcl::PointXYZ>::Ptr tree;
    tree.reset(new pcl::KdTreeFLANN<pcl::PointXYZ>);

    tree->setInputCloud(cloudb);
    return tree;
}

void offlineLocalization::processOccupancyGrid(const nav_msgs::OccupancyGrid &occupancy_grid_msg)
{
    ROS_INFO("[Offline Localization] Received Occupancy Grid Map with frame id: [%s]", occupancy_grid_msg.header.frame_id.c_str());

    float resolution = occupancy_grid_msg.info.resolution;
    float width = occupancy_grid_msg.info.width;
    float height = occupancy_grid_msg.info.height;

    float origin_x = occupancy_grid_msg.info.origin.position.x;
    float origin_y = occupancy_grid_msg.info.origin.position.y;

    cloud_xyz = boost::shared_ptr<pcl::PointCloud<pcl::PointXYZ>>(new pcl::PointCloud<pcl::PointXYZ>());

    cloud_xyz->height = 1;
    cloud_xyz->is_dense = false;
    std_msgs::Header cloud_header;
    cloud_header.stamp = ros::Time(0.0);
    cloud_header.frame_id = "map";

    cloud_xyz->header = pcl_conversions::toPCL(cloud_header);
    map_received = true;

    pcl::PointXYZ point_xyz;

    for (int y = 0; y < height; y++)
    {
        for (int x = 0; x < width; x++)
        {
            if (occupancy_grid_msg.data[x + y * width] == 100)
            {
                point_xyz.x = (.5f + x) * resolution + origin_x;
                point_xyz.y = (.5f + y) * resolution + origin_y;
                point_xyz.z = 0;
                cloud_xyz->points.push_back(point_xyz);
            }
        }
    }

    cloud_xyz->width = cloud_xyz->points.size();
    pcl::io::savePCDFileASCII ("/home/mahi/icp/test_pcd.pcd", *cloud_xyz);

    tf::TransformListener tf_listener;
    if (!tf_listener.waitForTransform("map", cloud_xyz->header.frame_id, ros::Time(0), ros::Duration(0.1)))
    {
        ROS_ERROR("[Offline Localization] Transform from '%s' to 'map' not available.", cloud_xyz->header.frame_id.c_str());
        return;
    }

    mapTree = createKdTree(cloud_xyz);
    input_set = true;

    pcl::toROSMsg(*cloud_xyz, *output_map_cloud);
    ROS_INFO("[Offline Localization] Publishing Map cloud with %ld points in frame %s", cloud_xyz->points.size(), output_map_cloud->header.frame_id.c_str());
}

void offlineLocalization::initialPoseReceived(
    const geometry_msgs::PoseWithCovarianceStampedConstPtr &msg)
{
    if (msg->header.frame_id.empty())
    {
        ROS_WARN("[Offline Localization] Received initial pose with empty frame_id");
        return;
    }

    if (msg->header.frame_id != "map")
    {
        ROS_WARN("[Offline Localization] Received initial pose with unexpected frame_id: %s. Expected 'map'", msg->header.frame_id.c_str());
        return;
    }

    try
    {
        Eigen::Matrix3f mat3 = Eigen::Quaternionf(msg->pose.pose.orientation.w,
                                                  msg->pose.pose.orientation.x,
                                                  msg->pose.pose.orientation.y,
                                                  msg->pose.pose.orientation.z)
                                   .toRotationMatrix();
        prev_guess.block(0, 0, 3, 3) = mat3;
        prev_guess(0, 3) = msg->pose.pose.position.x;
        prev_guess(1, 3) = msg->pose.pose.position.y;
        pose_sent = true;
        ROS_INFO("[Offline Localization] Received initial pose in frame 'map'");
    }
    catch (const std::exception &e)
    {
        ROS_ERROR("[Offline Localization] Error processing initial pose: %s", e.what());
    }
}

void offlineLocalization::publishTransform(const Eigen::Matrix4d& transformation_matrix)
{
    tf::Transform transform;
    transform.setOrigin(tf::Vector3(transformation_matrix(0, 3), transformation_matrix(1, 3), transformation_matrix(2, 3)));

    Eigen::Matrix3d rotation_matrix = transformation_matrix.block<3, 3>(0, 0);
    Eigen::Quaterniond quaternion(rotation_matrix);
    transform.setRotation(tf::Quaternion(quaternion.x(), quaternion.y(), quaternion.z(), quaternion.w()));

    static tf::TransformBroadcaster br;

    br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "base_link", "map"));
    ROS_INFO("[Offline Localization] Published transform from base_link to map");

}

void offlineLocalization::sourceLaserCallback(const sensor_msgs::LaserScan::ConstPtr &msg)
{
    if (!map_received)
    {
        ROS_WARN("[Offline Localization] Waiting for Map to be available");
        return;
    }

    ros::spinOnce();
    Eigen::Matrix4d manual_transform; 

    input_cloud = boost::shared_ptr<pcl::PointCloud<pcl::PointXYZ>>(new pcl::PointCloud<pcl::PointXYZ>());
    *input_cloud = *cloud_xyz; 
    ROS_INFO("PUL %ld", msg->ranges.size());

    // input_cloud = boost::make_shared<pcl::PointCloud<pcl::PointXYZ>>(*cloud_xyz); // Copy the cloud_xyz content
    laser_output_pub.publish(input_cloud);

    sensor_msgs::PointCloud2 transformed_scan;
    if (!transformLaserScanToMapFrame(msg, transformed_scan))
    {
        return;
    }

    pcl::PointCloud<pcl::PointXYZ>::Ptr target_cloud = LaserScanPclConversion::laserScanToPclPtr(msg);
    pcl::io::savePCDFileASCII ("/home/mahi/icp/scan_pcd.pcd", *target_cloud);
    return;

    pcl::PointCloud<pcl::PointXYZ>::Ptr tmp_input_cloud = boost::make_shared<pcl::PointCloud<pcl::PointXYZ>>(*input_cloud);
    ROS_INFO("map cloud size %u-%u", tmp_input_cloud->width, tmp_input_cloud->height);
    ROS_INFO("scan cloud size %u-%u ", target_cloud->width, target_cloud->height);

    std::vector<Eigen::Matrix4d> further_interpretation_transformation_matrix;
    std::vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> further_interpretation_point_cloud;
    Eigen::Matrix4d final_transformation_matrix;

    if (localizationMethodStr == "icp")
    {
        performICP(tmp_input_cloud, target_cloud, further_interpretation_transformation_matrix, further_interpretation_point_cloud);
    }
    else if (localizationMethodStr == "ndt")
    {
        performNDT(tmp_input_cloud, target_cloud, further_interpretation_transformation_matrix, further_interpretation_point_cloud);
    }
    else
    {
        ROS_ERROR("[Offline Localization] Unknown localization method: %s", localizationMethodStr.c_str());
        return;
    }

    applyFinalTransformation(further_interpretation_transformation_matrix, final_transformation_matrix);

    publishResult(tmp_input_cloud, msg->header.frame_id, final_transformation_matrix);
}

bool offlineLocalization::validateMapFrame()
{
    tf::TransformListener listener;
    if (listener.frameExists("map"))
    {
        ROS_INFO("[Offline Localization] The 'map' frame is available.");
        return true;
    }
    return false;
}

bool offlineLocalization::transformLaserScanToMapFrame(const sensor_msgs::LaserScan::ConstPtr &msg, sensor_msgs::PointCloud2 &transformed_scan)
{
    tf::TransformListener tf_listener_(ros::Duration(60));
    tf::StampedTransform transform;

    ROS_INFO("[Offline Localization] Max Correspondence Distance Set: %f", max_distance);
    ROS_INFO("[Offline Localization] Max Iterations Set: %d", max_iterations);
    if (!tf_listener_.canTransform("map", "base_link", ros::Time(0)))
    {
        ROS_WARN("[Offline Localization] Transform not available at the desired timestamp.");
        return false;
    }

    try
    {
        tf_listener_.waitForTransform("map", msg->header.frame_id, ros::Time(0), ros::Duration(1.0));
        tf_listener_.lookupTransform("map", msg->header.frame_id, ros::Time(0), transform);

        ROS_INFO("[Offline Localization] Transformed laser scan to map frame");
        return true;
    }
    catch (const tf::TransformException &ex)
    {
        ROS_ERROR("[Offline Localization] Failed to transform laser scan to map frame: %s", ex.what());
        return false;
    }
}

void offlineLocalization::performICP(const pcl::PointCloud<pcl::PointXYZ>::Ptr &tmp_input_cloud,
                                     const pcl::PointCloud<pcl::PointXYZ>::Ptr &target_cloud,
                                     std::vector<Eigen::Matrix4d> &further_interpretation_transformation_matrix,
                                     std::vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> &further_interpretation_point_cloud)
{
    // stored the 1st calculated cloud to the vector for further
    // interpretation
    Eigen::Matrix4d initial_transformation_matrix;
    if (runICP(tmp_input_cloud, target_cloud, max_iterations, fitness_threshold, initial_transformation_matrix, true))
    {
        tf::Transform tf_initial = LaserScanPclConversion::eigenMatrix4dToTransform(initial_transformation_matrix);

        pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud_initial(new pcl::PointCloud<pcl::PointXYZ>);
        applyTransformation(initial_transformation_matrix, tmp_input_cloud, transformed_cloud_initial);

        transformed_pattern_rviz_pub.publish(transformed_cloud_initial);

        for (int i = 0; i < further_interpretation_count; i++)
        {
            Eigen::Matrix4d calculated_matrix;
            pcl::PointCloud<pcl::PointXYZ>::Ptr calculated_cloud(new pcl::PointCloud<pcl::PointXYZ>);

            if (runICP(transformed_cloud_initial, target_cloud, max_iterations,
                       further_interpretation_threshold, calculated_matrix, false))
            {
                pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud_calculated(new pcl::PointCloud<pcl::PointXYZ>);
                applyTransformation(calculated_matrix, transformed_cloud_initial, transformed_cloud_calculated);

                further_interpretation_transformation_matrix.push_back(calculated_matrix);
                further_interpretation_point_cloud.push_back(transformed_cloud_calculated);
            }
            else
            {
                break;
            }
        }
    }
}

void offlineLocalization::applyFinalTransformation(const std::vector<Eigen::Matrix4d> &further_interpretation_transformation_matrix, Eigen::Matrix4d &final_transformation_matrix)
{
    // Accumulate transformations
    final_transformation_matrix = mat.addTransformation(further_interpretation_transformation_matrix);
}

void offlineLocalization::publishResult(const pcl::PointCloud<pcl::PointXYZ>::Ptr &tmp_input_cloud, const std::string &frame_id, Eigen::Matrix4d &final_transformation_matrix)
{
    // Generate pose from the final transformation matrix and publish out
    tf::Transform final_transform = LaserScanPclConversion::eigenMatrix4dToTransform(final_transformation_matrix.cast<double>());

    geometry_msgs::PoseStamped res_pose;
    tf::poseTFToMsg(final_transform, res_pose.pose);
    res_pose.header.frame_id = "map";
    res_pose.header.stamp = ros::Time::now();
    pose_stamped_pub.publish(res_pose);

    pose_sent = true;
    if (to_publish_tf)
    {
        static tf::TransformBroadcaster tf_broadcaster;
        tf_broadcaster.sendTransform(tf::StampedTransform(final_transform, ros::Time::now(), frame_id, tmp_input_cloud->header.frame_id));
    }
    else
    {
        ROS_ERROR("[Offline Localization] ICP/NDT failed. No Robot pose sent.");
    }
}

bool offlineLocalization::performNDT(const pcl::PointCloud<pcl::PointXYZ>::Ptr &tmp_input_cloud,
                                     const pcl::PointCloud<pcl::PointXYZ>::Ptr &target_cloud,
                                     std::vector<Eigen::Matrix4d> &further_interpretation_transformation_matrix,
                                     std::vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> &further_interpretation_point_cloud)
{
    Eigen::Matrix4d initial_transformation_matrix;
    if (runNDT(tmp_input_cloud, target_cloud, max_iterations, fitness_threshold, initial_transformation_matrix, true))
    {
        tf::Transform tf_initial = LaserScanPclConversion::eigenMatrix4dToTransform(initial_transformation_matrix);

        pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud_initial(new pcl::PointCloud<pcl::PointXYZ>);
        applyTransformation(initial_transformation_matrix, tmp_input_cloud, transformed_cloud_initial);

        transformed_pattern_rviz_pub.publish(transformed_cloud_initial);

        for (int i = 0; i < further_interpretation_count; i++)
        {
            Eigen::Matrix4d calculated_matrix;
            pcl::PointCloud<pcl::PointXYZ>::Ptr calculated_cloud(new pcl::PointCloud<pcl::PointXYZ>);

            if (runNDT(transformed_cloud_initial, target_cloud, max_iterations,
                       further_interpretation_threshold, calculated_matrix, false))
            {
                pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud_calculated(new pcl::PointCloud<pcl::PointXYZ>);
                applyTransformation(calculated_matrix, transformed_cloud_initial, transformed_cloud_calculated);

                further_interpretation_transformation_matrix.push_back(calculated_matrix);
                further_interpretation_point_cloud.push_back(transformed_cloud_calculated);
            }
            else
            {
                break;
            }
        }
    }
}

bool offlineLocalization::runNDT(const pcl::PointCloud<pcl::PointXYZ>::Ptr &source,
                                 const pcl::PointCloud<pcl::PointXYZ>::Ptr &target,
                                 int iterations, double threshold,
                                 Eigen::Matrix4d &result, bool store_required)
{
    if (pose_sent)
    {
        init_guess = prev_guess;
    }
    else
    {
        init_guess(0, 3) = -7.141;
        init_guess(1, 3) = -38.5;
        init_guess(2, 3) = 1.0;
        init_guess(3, 3) = 1.0;
    }

    boost::shared_ptr<pclomp::NormalDistributionsTransform<pcl::PointXYZ, pcl::PointXYZ>> ndt(new pclomp::NormalDistributionsTransform<pcl::PointXYZ, pcl::PointXYZ>());
    ndt->setInputSource(source);
    ndt->setInputTarget(target);
    ndt->setTransformationEpsilon(0.01);
    ndt->setMaximumIterations(32);
    ndt->setResolution(1.0);
    ndt->setNeighborhoodSearchMethod(pclomp::DIRECT7);
    ndt->setNumThreads(5);

    pcl::PointCloud<pcl::PointXYZ>::Ptr output_cloud(new pcl::PointCloud<pcl::PointXYZ>);
    ndt->align(*output_cloud, init_guess);
    std_msgs::Float32 localization_score;

    localization_score.data = ndt->getFitnessScore();
    score_pub.publish(localization_score);

    if (ndt->hasConverged() && ndt->getFitnessScore() <= threshold)
    {
        std::cout << "converged." << std::endl
                  << "The score is " << ndt->getFitnessScore() << std::endl;
        std::cout << "Transformation matrix:" << std::endl;
        std::cout << ndt->getFinalTransformation() << std::endl;
        result = ndt->getFinalTransformation().cast<double>();
    }
    else
    {
        ROS_ERROR("[Offline Localization] NDT failed. Fitness score: %f", ndt->getFitnessScore());

        return false;
    }

    init_guess.block<3, 3>(0, 0) = ndt->getFinalTransformation().block<3, 3>(0, 0);
    init_guess.block<3, 1>(0, 3) = ndt->getFinalTransformation().block<3, 1>(0, 3);

    prev_guess = init_guess;
    return true;
}

// void offlineLocalization::sourceLaserCallback(const sensor_msgs::LaserScan::ConstPtr &msg)
// {
//     if (!map_received)
//     {
//         ROS_WARN("[Offline Localization] Waiting for Map to be available");
//         return;
//     }

//     tf::TransformListener listener;
//     if (listener.frameExists("map"))
//     {
//         ROS_INFO("[Offline Localization] The 'map' frame is available.");
//     }

//     input_cloud = boost::shared_ptr<pcl::PointCloud<pcl::PointXYZ>>(new pcl::PointCloud<pcl::PointXYZ>());
//     *input_cloud = *cloud_xyz; // Copy the cloud_xyz content

//     // Transform laser scan to the map frame
//     sensor_msgs::PointCloud2 transformed_scan;
//     tf::TransformListener tf_listener_;
//     Eigen::Matrix4d initial_transformation_matrix, final_transformation_matrix;
//     tf::StampedTransform transform;

//     ROS_INFO("[Offline Localization] Max Correspondence Distance Set: %f", max_distance);
//     ROS_INFO("[Offline Localization] Max Iterations Set: %d", max_iterations);

//     try
//     {
//         tf_listener_.waitForTransform("map", msg->header.frame_id, msg->header.stamp, ros::Duration(0.5));
//         tf_listener_.lookupTransform("map", msg->header.frame_id, msg->header.stamp, transform);

//         ROS_INFO("[Offline Localization] Transformed laser scan to map frame");
//     }
//     catch (const tf::TransformException &ex)
//     {
//         ROS_ERROR("[Offline Localization] Failed to transform laser scan to map frame: %s", ex.what());
//         return;
//     }

//     // laser_projector_.transformLaserScanToPointCloud("map", *msg, transformed_scan, tf_listener_);
//     pcl::PointCloud<pcl::PointXYZ>::Ptr target_cloud =
//       LaserScanPclConversion::laserScanToPclPtr(msg);
//     // Convert transformed scan to pcl point cloud
//     pcl::PCLPointCloud2 pcl_point_cloud2;
//     pcl_conversions::toPCL(transformed_scan, pcl_point_cloud2);

//     pcl::PointCloud<pcl::PointXYZ>::Ptr live_scan(new pcl::PointCloud<pcl::PointXYZ>);
//     pcl::fromPCLPointCloud2(pcl_point_cloud2, *live_scan);
//     laser_output_pub.publish(input_cloud);

//     pcl::PointCloud<pcl::PointXYZ>::Ptr tmp_input_cloud(new pcl::PointCloud<pcl::PointXYZ>(*input_cloud)); // Make a deep copy

//     std::vector<Eigen::Matrix4d> further_interpretation_transformation_matrix;
//     std::vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> further_interpretation_point_cloud;

//     if(localizationMethodStr == "icp"){

//     }

//     // Perform ICP
//     if (runICP(tmp_input_cloud, target_cloud, max_iterations, fitness_threshold, initial_transformation_matrix, true))
//     {
//         tf::Transform tf_initial = LaserScanPclConversion::eigenMatrix4dToTransform(initial_transformation_matrix);

//         // Apply initial transformation to the input cloud
//         pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud_initial(new pcl::PointCloud<pcl::PointXYZ>);
//         applyTransformation(initial_transformation_matrix, tmp_input_cloud, transformed_cloud_initial);

//         // Visualize the initial transformed cloud
//         transformed_pattern_rviz_pub.publish(transformed_cloud_initial);

//         // Further ICP iterations
//         for (int i = 0; i < further_interpretation_count; i++)
//         {
//             Eigen::Matrix4d calculated_matrix;
//             pcl::PointCloud<pcl::PointXYZ>::Ptr calculated_cloud(new pcl::PointCloud<pcl::PointXYZ>);

//             if (runICP(transformed_cloud_initial, target_cloud, max_iterations,
//                        further_interpretation_threshold, calculated_matrix, false))
//             {
//                 // Apply calculated transformation to the transformed cloud
//                 pcl::PointCloud<pcl::PointXYZ>::Ptr transformed_cloud_calculated(new pcl::PointCloud<pcl::PointXYZ>);
//                 applyTransformation(calculated_matrix, transformed_cloud_initial, transformed_cloud_calculated);

//                 further_interpretation_transformation_matrix.push_back(calculated_matrix);
//                 further_interpretation_point_cloud.push_back(transformed_cloud_calculated);
//             }
//             else
//             {
//                 break;
//             }
//         }

//         // Accumulate transformations (Trail and error for iteration testing for alignment)
//         final_transformation_matrix = mat.addTransformation(further_interpretation_transformation_matrix);

//         // generate pose from the final transformation matrix and publish out
//         tf::Transform final_transform = LaserScanPclConversion::eigenMatrix4dToTransform(final_transformation_matrix.cast<double>());

//         geometry_msgs::PoseStamped res_pose;
//         tf::poseTFToMsg(final_transform, res_pose.pose);
//         res_pose.header.frame_id = "map";
//         res_pose.header.stamp = ros::Time::now();
//         pose_stamped_pub.publish(res_pose);

//         pose_sent = true;
//         if (to_publish_tf)
//         {
//             static tf::TransformBroadcaster tf_broadcaster;
//             tf_broadcaster.sendTransform(tf::StampedTransform(final_transform, ros::Time::now(), msg->header.frame_id, tmp_input_cloud->header.frame_id));
//         }
//         else
//         {
//             ROS_ERROR("[Offline Localization] ICP failed. No Robot pose sent.");
//         }
//     }
// }


bool offlineLocalization::runICP(const pcl::PointCloud<pcl::PointXYZ>::Ptr &source,
                                 const pcl::PointCloud<pcl::PointXYZ>::Ptr &target,
                                 int iterations, double threshold,
                                 Eigen::Matrix4d &result, bool store_required)
{
    // pcl::CorrespondencesPtr correspondencematch = this->icpExposed::getCorrespondencesPtr();
    pcl::IterativeClosestPoint<pcl::PointXYZ, pcl::PointXYZ> icp;
    // Eigen::Matrix4d transformation_matrix = Eigen::Matrix4d::Identity ();

    // double theta = M_PI / 8;  // The angle of rotation in radians
    // transformation_matrix (0, 0) = std::cos (theta);
    // transformation_matrix (0, 1) = -sin (theta);
    // transformation_matrix (1, 0) = sin (theta);
    // transformation_matrix (1, 1) = std::cos (theta);
  
    // // A translation on Z axis (0.4 meters)
    // transformation_matrix (2, 3) = 0.4;
    // std::cout << "Applying this rigid transformation to: cloud_in -> cloud_icp" << std::endl;
    // ROS_INFO_STREAM("", << transformation_matrix);

    // pcl::transformPointCloud (*cloud_in, *cloud_icp, transformation_matrix);
    // *cloud_tr = *cloud_icp;


    if (pose_sent)
    {
        init_guess = prev_guess;
    }
    else
    {
        Eigen::Matrix4d::Identity ();
        // init_guess(0, 3) = -7.1466;
        // init_guess(1, 3) = -38.5;
        // init_guess(2, 3) = 1.0;
        // init_guess(3, 3) = 1.0;
    }

    ROS_INFO("[Offline Localization] Running ICP");

    icp.setInputSource(source);
    icp.setInputTarget(target);
    icp.setTransformationEpsilon(1e-6);
    icp.setMaxCorrespondenceDistance(1.0);
    icp.setMaximumIterations(200);


    pcl::PointCloud<pcl::PointXYZ> output_cloud;
    icp.align(output_cloud, init_guess);
    // std_msgs::Float32 localization_score;
    // localization_score.data = icp.getFitnessScore();
    // score_pub.publish(localization_score);

    if (icp.hasConverged()) //&& icp.getFitnessScore() <= threshold)
    {
        ROS_INFO("[Offline Localization] Converged %f", icp.getFitnessScore() );
        if (store_required)
        {
            stored_fitness_score.push_back(icp.getFitnessScore());
        }
        result = icp.getFinalTransformation().cast<double>();
    }
    else
    {
        ROS_ERROR("[Offline Localization] ICP failed. Fitness score: %f", icp.getFitnessScore());
        // Add additional error handling if needed
        return false;
    }

    init_guess.block<3, 3>(0, 0) = icp.getFinalTransformation().block<3, 3>(0, 0);
    init_guess.block<3, 1>(0, 3) = icp.getFinalTransformation().block<3, 1>(0, 3);
    prev_guess = init_guess;
    return true;
}

void offlineLocalization::applyTransformation(const Eigen::Matrix4d &transformation,
                                              const pcl::PointCloud<pcl::PointXYZ>::Ptr &input_cloud,
                                              pcl::PointCloud<pcl::PointXYZ>::Ptr &output_cloud)
{
    tf::Transform tf = LaserScanPclConversion::eigenMatrix4dToTransform(transformation);
    pcl_ros::transformPointCloud(*input_cloud, *output_cloud, tf);
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, "offline_localization_manager");

    offlineLocalization laser;

    ros::AsyncSpinner spinner(5);

    ros::Rate loop_rate(30.0);
    spinner.start();
    while (ros::ok())
    {
        ros::spinOnce();
        loop_rate.sleep();
    }
    return 0;
}